# cs6035-machine-learning-2025-solved



**<span style='color:red'>TO GET THIS SOLUTION VISIT:</span>** https://www.ankitcodinghub.com/product/cs6035-machine-learning-2025-solved/

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;127315&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;4&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (4 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CS6035 Machine Learning 2025 Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">
            
<div class="kksr-stars">
    
<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
    
<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">
            

<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>
                

<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (4 votes)    </div>
    </div>
Learning Goals of this Project:

<ul>
<li>Learning basic Pandas Dataframe manipulations</li>
<li>Learning more about Machine Learning (ML) Classification models and how they are used in a Cybersecurity context.</li>
<li>Learning about basic data pipelines and transformations.</li>
<li>Learning how to write and use unit tests when developing Python code.</li>
</ul>
Important Highlights

<ul>
<li>You can do this project on your host, you do not need to use the VM.</li>
<li>Please see the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/setup.html">Setup</a>&nbsp;page for videos and instructions about project setup.</li>
<li>Keep the VM around for the final project (Summer 24), Web Security.</li>
<li>Please watch the provided videos below to see how to setup your environment, we can’t provide broad support here</li>
<li>There are only 25 submissions allowed! This is because Gradescope is a limited resource. It’s improper to test your code against Gradescope.</li>
<li><strong>We have provided a local testing suite, be sure to pass that completely before you submit to Gradescope.</strong></li>
</ul>
Important Reference Materials:

<ul>
<li><a href="https://numpy.org/doc/">NumPy Documentation</a></li>
<li><a href="https://pandas.pydata.org/docs/">Pandas Documentation</a></li>
<li><a href="https://scikit-learn.org/stable/index.html">Scikit-learn Documentation</a></li>
</ul>
Project Overview Video

This is a 16 minute video by the project creator, it covers project concepts.

There are other videos on the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/setup.html">Setup</a>&nbsp;page that cover installation and other subjects.

BACKGROUND

Many of the Projects in CS6035 are focused on offensive security tasks. These are related to&nbsp;<a href="https://en.wikipedia.org/wiki/Red_team">Red Team</a>&nbsp;activities/tasks that many of us may associate with cybersecurity. This project will be focused on defensive security tasks, which are usually considered&nbsp;<a href="https://en.wikipedia.org/wiki/Blue_team_(computer_security)">Blue Team</a>&nbsp;activities that are done by many corporate teams.

Historically, many defensive security professionals have investigated malicious activity, files, and code. They investigate these to create patterns (often called signatures) that can be used to detect (and prevent) malicious activity, files, and code when that pattern is used again. What this means is that these simple methods only were effective on known threats.

This approach was relatively effective in preventing known malware from infecting systems, but it did nothing to protect against novel attacks. As attackers became more sophisticated, they learned to tweak or simply encode their malicious activity, files, or code to avoid detection from these simple pattern matching detections.

With this background information, it would be nice if a more general solution could give a score to activity, files, and code that pass through corporate systems every day. This solution would inform the security team that while a certain pattern may not exactly fit a signature of known malicious activity, files, or code it appears to be very similar to examples that were seen in the past that were malicious.

Luckily machine learning models can do exactly that if provided with proper training data! Thus, it is no surprise that one of the most powerful tools in the hands of defensive cybersecurity professionals is Machine Learning. Modern detection systems usually use a combination of machine learning models and pattern matching (regular expressions) to detect and prevent malicious activity on networks and devices.

This project will focus on teaching the fundamentals of data analysis and building/testing your own machine learning models in python. You’ll be using the open source libraries Pandas and Scikit-Learn.

Cybersecurity Machine Learning Careers and Trends

<ul>
<li>Machine learning in cybersecurity is a growing field. The area was considered among top trends by&nbsp;<a href="https://www.mckinsey.com/capabilities/risk-and-resilience/our-insights/cybersecurity/cybersecurity-trends-looking-over-the-horizon">McKinsey</a>&nbsp;in 2022.</li>
<li>In the&nbsp;<a href="https://www.comptia.org/content/research/cybersecurity-trends-research">CompTIA State of Cybersecurity 2024</a>&nbsp;it says last year there were 660,000 unfilled Cybersecurity positions. Also in the section titled&nbsp;<em>Product: AI Drives the Cybersecurity Product Set to New Heights</em>&nbsp;they note that 56% of respondents use AI and Machine Learning for Cybersecurity.</li>
</ul>
Additional Information

<ul>
<li><a href="https://www.crowdstrike.com/cybersecurity-101/machine-learning-cybersecurity/">ML in Cybersecurity – Crowdstrike</a></li>
<li><a href="https://www.ibm.com/security/artificial-intelligence">AI for Cybersecurity – IBM</a></li>
<li><a href="https://www.deloitte.com/global/en/our-thinking/insights/topics/technology-management/tech-trends/2022/future-of-cybersecurity-and-ai.html">Future of Cybersecurity and AI – Deloitte</a></li>
</ul>
Table of contents

<ul>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/FAQ.html">FAQ</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/setup.html">Setup</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html">Task 1</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html">Task 2</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task3.html">Task 3</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task4.html">Task 4</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task5.html">Task 5</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Notebooks.html">Optional Notebooks</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/video_tasks.html">Video Tasks</a></li>
</ul>
&nbsp;

Task 1:

Task 1

For the first task, let’s get familiar with some pandas basics. pandas is a Python library that deals with Dataframes, which you can think of as a Python class that handles tabular data. In the real world, you would create graphics and other visuals to better understand the dataset you are working with. You would also use plotting tools like PowerBi, Tableau, Data Studio, and Matplotlib. This step is generally known as Exploratory Data Analysis. Since we are using an autograder for this class, we will skip the plotting for this project.

For this task, we have released a local test suite. If you are struggling to understand the expected input and outputs for a function, please set up the test suite and use it to debug your function. Please note that the return lines for the provided skeleton functions are placeholders for the data types that the tests are expecting.

<strong>It’s critical you pass all tests locally before you submit to Gradescope for credit. Do not use Gradescope for debugging.</strong>

<strong>Theory</strong>

In this Task, we’re not yet getting into theory. It’s more nuts and bolts – you will learn the basics of pandas. pandas dataframes are something of a glorified list of lists, mixed in with a dictionary. You get a table of values with rows and columns, and you can modify the column names and index values for the rows. There are numerous functions built into pandas to let you manipulate the data in the dataframe.

To be clear, pandas is not part of Python, so when you look up docs, you’ll specifically want&nbsp;<a href="https://pandas.pydata.org/docs/reference/index.html">the official Pydata pandas docs</a>. Note that we linked to the API docs here, this is the core of the docs you’ll be looking at.

You can always get started trying to solve a problem by looking at Stack Overflow posts in Google search results. There you’ll find ideas about how to use the pandas library. In the end, however, you should find yourself in the habit of looking directly at the docs for whichever library you are using, pandas in this case.

For those who might need a concrete example to get started, here’s how you would take a pandas dataframe column and return the average of its values:

import pandas as pd

<em># create a dataframe from a Python dict</em>

df = pd.DataFrame({“color”:[“yellow”, “green”, “purple”, “red”], “weight”:[124,4.56,384,-2]})

df <em># shows the dataframe</em>

<table>
<thead>
<tr>
<td><strong>index</strong></td>
<td><strong>color</strong></td>
<td><strong>weight</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>yellow</td>
<td>124</td>
</tr>
<tr>
<td>1</td>
<td>green</td>
<td>4.56</td>
</tr>
<tr>
<td>2</td>
<td>purple</td>
<td>384.00</td>
</tr>
<tr>
<td>4</td>
<td>red</td>
<td>-2.00</td>
</tr>
</tbody>
</table>
Note that the column names are [“color”,”weight”] while the index is [0,1,2,3…] where […] the brackets denote a list.

Now that we have created a dataframe, we can find the average weight by summing the values under ‘weight’ and dividing them by the sum:

average = df[‘weight’].sum() / len(df[‘weight’])

average <em># if you put a variable as the last line, the variable is printed</em>

127.63999999999999

Note: In the example above, we’re not paying attention to rounding, you will need to round your answers to the precision asked for in each Task.

Also note, we are using slightly older versions of the pandas, Python and other libraries so be sure to look at the docs for the appropriate library version. Often there’s a drop-down at the top of docs sites to select the older version.

Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details about submitting your work.

Useful Links:

<ul>
<li><a href="https://pandas.pydata.org/docs/">pandas documentation — pandas documentation (pydata.org)</a></li>
<li><a href="https://www.ibm.com/topics/exploratory-data-analysis">What is Exploratory Data Analysis? – IBM</a></li>
<li><a href="https://www.kdnuggets.com/2020/05/top-10-data-visualization-tools-every-data-scientist.html">Top Data Visualization Tools – KDnuggets</a></li>
</ul>
Deliverables:

<ul>
<li>Complete the functions in task1.py</li>
<li>For this task we have released a local test suite please set that up and use it to debug your function.</li>
<li>Submit task1.py to gradescope</li>
</ul>
Instructions:

The Task1.py file has function skeletons that you will complete with Python code, mostly using the pandas library. The goal of each of these functions is to give you familiarity with the pandas library and some general Python concepts like classes, which you may not have seen before. See information about the function’s inputs, outputs, and skeletons below.

Table of contents

<ol>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#find_data_type">find_data_type</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#set_index_col">set_index_col</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#reset_index_col">reset_index_col</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#set_col_type">set_col_type</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#make_df_from_2d_array">make_DF_from_2d_array</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#sort_df_by_column">sort_DF_by_column</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#drop_na_cols">drop_NA_cols</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#drop_na_rows">drop_NA_rows</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#make_new_column">make_new_column</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#left_merge_dfs_by_column">left_merge_DFs_by_column</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#simpleclass">simpleClass</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task1.html#find_dataset_statistics">find_dataset_statistics</a></li>
</ol>
find_data_type

In this function you will take a dataset and the name of a column in it. You will return the column’s data type.

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dtypes.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dtypes.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>column_name&nbsp;– a Python string (str)</li>
</ul>
OUTPUTS

np.dtype&nbsp;– data type of the column

Function Skeleton

def find_data_type(dataset:pd.DataFrame,column_name:str) -&gt; np.dtype:

return np.dtype()

set_index_col

In this function you will take a dataset and a series and set the index of the dataset to be the series

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Index.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Index.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>index&nbsp;– a pandas series that contains an index for the dataset</li>
</ul>
OUTPUTS

a pandas DataFrame indexed by the given index series

Function Skeleton

def set_index_col(dataset:pd.DataFrame,index:pd.Series) -&gt; pd.DataFrame:

return pd.DataFrame()

reset_index_col

In this function you will take a dataset with an index already set and reindex the dataset from 0 to n-1, dropping the old index

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
</ul>
OUTPUTS

a pandas DataFrame indexed from 0 to n-1

Function Skeleton

def reset_index_col(dataset:pd.DataFrame) -&gt; pd.DataFrame:

return pd.DataFrame()

set_col_type

In this function you will be given a DataFrame, column name and column type. You will edit the dataset to take the column name you are given and set it to be the type given in the input variable

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.astype.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.astype.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>column_name&nbsp;– a string containing the name of a column</li>
<li>new_col_type&nbsp;– a Python type to change the column to</li>
</ul>
OUTPUTS

a pandas DataFrame with the column in&nbsp;column_name&nbsp;changed to the type in&nbsp;new_col_type

Function Skeleton

<em># Set astype (string, int, datetime)</em>

def set_col_type(dataset:pd.DataFrame,column_name:str,new_col_type:type) -&gt; pd.DataFrame:

return pd.DataFrame()

make_DF_from_2d_array

In this function you will take data in an array as well as column and row labels and use that information to create a pandas DataFrame

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html</a>

INPUTS

<ul>
<li>array_2d&nbsp;– a 2 dimensional numpy array of values</li>
<li>column_name_list&nbsp;– a list of strings holding column names</li>
<li>index&nbsp;– a pandas series holding the row index’s</li>
</ul>
OUTPUTS

a pandas DataFrame with columns set from&nbsp;column_name_list, row index set from&nbsp;index&nbsp;and data set from&nbsp;array_2d

Function Skeleton

<em># Take Matrix of numbers and make it into a DataFrame with column name and index numbering</em>

def make_DF_from_2d_array(array_2d:np.array,column_name_list:list[str],index:pd.Series) -&gt; pd.DataFrame:

return pd.DataFrame()

sort_DF_by_column

In this function, you are given a dataset and column name. You will return a sorted dataset (sorting rows by the value of the specified column) either in descending or ascending order, depending on the value in the&nbsp;descending&nbsp;variable.

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>column_name&nbsp;– a string that contains the column name to sort the data on</li>
<li>descending&nbsp;– a boolean value (True&nbsp;or&nbsp;False) for if the column should be sorted in descending order</li>
</ul>
OUTPUTS

a pandas DataFrame sorted by the given column name and in descending or ascending order depending on the value of the&nbsp;descending&nbsp;variable

Function Skeleton

<em># Sort DataFrame by values</em>

def sort_DF_by_column(dataset:pd.DataFrame,column_name:str,descending:bool) -&gt; pd.DataFrame:

return pd.DataFrame()

drop_NA_cols

In this function you are given a DataFrame. You will return a DataFrame with any columns containing&nbsp;NA&nbsp;values dropped

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
</ul>
OUTPUTS

a pandas DataFrame with any columns that contain an&nbsp;NA&nbsp;value dropped

Function Skeleton

<em># Drop NA values in DataFrame Columns </em>

def drop_NA_cols(dataset:pd.DataFrame) -&gt; pd.DataFrame:

return pd.DataFrame()

drop_NA_rows

In this function you are given a DataFrame you will return a DataFrame with any rows containing&nbsp;NA&nbsp;values dropped

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
</ul>
OUTPUTS

a pandas DataFrame with any rows that contain an&nbsp;NA&nbsp;value dropped

Function Skeleton

def drop_NA_rows(dataset:pd.DataFrame) -&gt; pd.DataFrame:

return pd.DataFrame()

make_new_column

In this function you are given a dataset, a new column name and a string value to fill in the new column. Add the new column to the dataset and return the dataset.

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/intro_tutorials/05_add_columns.html">https://pandas.pydata.org/pandas-docs/stable/getting_started/intro_tutorials/05_add_columns.html</a>

INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>new_column_name&nbsp;– a string containing the name of the new column to be created</li>
<li>new_column_value&nbsp;– a string containing a static value that will be set for the new column for every row</li>
</ul>
OUTPUTS

a pandas DataFrame with the new column created named&nbsp;new_column_name&nbsp;and filled with the value in&nbsp;new_column_value

Function Skeleton

def make_new_column(dataset:pd.DataFrame,new_column_name:str,new_column_value:list) -&gt; pd.DataFrame:

return pd.DataFrame()

left_merge_DFs_by_column

In this function you are given 2 datasets and the name of a column with which you will left join them on using the pandas merge method. The left dataset is&nbsp;dataset1&nbsp;right dataset is&nbsp;dataset2, for example purposes.

Useful Resources

<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html</a>&nbsp;<a href="https://stackoverflow.com/questions/53645882/pandas-merging-101">https://stackoverflow.com/questions/53645882/pandas-merging-101</a>

INPUTS

<ul>
<li>left_dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>right_dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>join_col_name&nbsp;– a string containing the column name to join the two DataFrames on</li>
</ul>
OUTPUTS

a pandas DataFrame containing the two datasets left joined together on the given column name

Function Skeleton

def left_merge_DFs_by_column(left_dataset:pd.DataFrame,right_dataset:pd.DataFrame,join_col_name:str) -&gt; pd.DataFrame:

return pd.DataFrame()

simpleClass

This project will require you to work with Python Classes. If you are not familiar with them we suggest learning a bit more about them.

You will take the inputs into the class initialization and set them as instance variables (of the same name) in the Python class.

Useful Resources

<a href="https://www.w3schools.com/python/python_classes.asp">https://www.w3schools.com/python/python_classes.asp</a>

INPUTS

<ul>
<li>length&nbsp;– an integer</li>
<li>width&nbsp;– an integer</li>
<li>height&nbsp;– an integer</li>
</ul>
OUTPUTS

None, just setup the&nbsp;<strong>init</strong>&nbsp;method in the class.

Function Skeleton

class simpleClass():

def __init__(self, length:int, width:int, height:int):

pass

find_dataset_statistics

Now that you have learned a bit about pandas DataFrames, we will use them to generate some simple summary statistics for a DataFrame. You will be given the dataset as an input variable, as well as a column name for a column in the dataset that serves as a label column. This label column contains binary values (0 and 1) that you also summarize, and also the variable to predict.

In this context:

<ul>
<li>0 represents a “negative” sample (e.g. if the column is IsAVirus and we think it is false)</li>
<li>1 represents a “positive” sample (e.g. if the column is IsAVirus and we think it is true)</li>
</ul>
This type of binary classification is common in machine learning tasks where we want to be able to predict the field. An example of where this could be useful would be if we were looking at network data, and the label column was&nbsp;IsVirus. We could then analyze the network data of Georgia Tech services and predict if incoming files look like a virus (and if we should alert the security team).

Useful Resources

<ul>
<li><a href="https://www.learndatasci.com/glossary/binary-classification/">https://www.learndatasci.com/glossary/binary-classification/</a></li>
<li><a href="https://developers.google.com/machine-learning/crash-course/framing/ml-terminology">https://developers.google.com/machine-learning/crash-course/framing/ml-terminology</a></li>
</ul>
INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>label_col&nbsp;– a string containing the name of the&nbsp;label&nbsp;column</li>
</ul>
OUTPUTS

<ul>
<li>n_records&nbsp;(int) – the number of rows in the dataset</li>
<li>n_columns&nbsp;(int) – the number of columns in the dataset</li>
<li>n_negative&nbsp;(int) – the number of “negative” samples in the dataset&nbsp;<strong>(the argument&nbsp;</strong>label<strong>&nbsp;column equals 0)</strong></li>
<li>n_positive&nbsp;(int) – the number of “positive” samples in the dataset&nbsp;<strong>(the argument&nbsp;</strong>label<strong>&nbsp;column equals 1)</strong></li>
<li>perc_positive&nbsp;(int) – the percentage (out of 100%) of positive samples in the dataset; truncate anything after the decimal</li>
</ul>
Hint: Consider using the int function to type cast decimals

Function Skeleton

def find_dataset_statistics(dataset:pd.DataFrame,label_col:str) -&gt; tuple[int,int,int,int,int]:

n_records = <em>#TODO</em>

n_columns = <em>#TODO</em>

n_negative = <em>#TODO</em>

n_positive = <em>#TODO</em>

perc_positive = <em>#TODO</em>

return n_records,n_columns,n_negative,n_positive,perc_positive

&nbsp;

&nbsp;

&nbsp;

&nbsp;

Task 2:

Now that you have a basic understanding of pandas and the dataset, it is time to dive into some more complex data processing tasks.

<strong>Theory</strong>

In machine learning a common goal is to train a model on one set of data. Then we validate the model on a similarly structured but different set of data. You could, for example, train the model on data you have collected historically. Then you would validate the model against real-time data as it comes in, seeing how well it predicts the new data coming in.

If you’re looking at a past dataset as we are in these tasks, we need to treat different parts of the data differently to be able to develop and test models. We segregate the data into test and training portions. We train the model on the training data and test the developed model on the test data to see how well it predicts the results.

<strong>You should never train your models on test data, only on training data.</strong>

Notes

At a high level it is important to hold out a subset of your data when you train a model. You can see what the expected performance is on unseen sample. Thus, you can determine if the resulting model is overfit (performs much better on training data vs test data).

Preprocessing data is essential because most models only take in numerical values. Therefore, categorical features need to be “encoded” to numerical values so that models can use them. A machine learning model may not be able to make sense of “green”, “blue” and “red.” In preprocessing, we’ll convert those to integer values 1, 2 and 3, for example. It’s an interesting question as to what happens when you have training data that has “green,” “red” and blue,” but your testing data says “yellow.”

Numerical scaling can be more or less useful depending on the type of model used, but it is especially important in linear models. Numerical scaling is typically taking positive value and “compressing” them into a range between 0 and 1 (inclusive) that retains the relationships among the original data.

These preprocessing techniques will provide you with options to augment your dataset and improve model performance.

Useful Links:

<ul>
<li><a href="https://developers.google.com/machine-learning/crash-course/training-and-test-sets/video-lecture">Training and Test Sets – Machine Learning – Google Developers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff">Bias–variance tradeoff – Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Overfitting">Overfitting – Wikipedia</a></li>
<li><a href="https://365datascience.com/tutorials/statistics-tutorials/numerical-categorical-data/">Categorical and Numerical Types of Data – 365 Data Science</a></li>
<li><a href="https://scikit-learn.org/stable/index.html">scikit-learn: machine learning in Python — scikit-learn 1.2.1 documentation</a></li>
</ul>
Deliverables:

<ul>
<li>Complete the functions and methods in task2.py</li>
<li>For this task we have released a local test suite please set that up and use it to debug your function.</li>
<li>Submit task2.py to Gradescope when you pass all local tests. Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details.</li>
</ul>
Instructions:

The Task2.py File has function skeletons that you will complete with python code (mostly using the pandas and scikit-learn libraries). The Goal of each of these functions is to give you familiarity with the applied concepts of Splitting and Preprocessing Data. See information about the Function’s Inputs, Outputs and Skeletons below

Table of contents

<ol>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#tts">tts</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#PreprocessDataset">PreprocessDataset</a>
<ol>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#preprocessdataset__init__">__init__</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#preprocessdatasetone_hot_encode_columns_train-and-one_hot_encode_columns_test">One Hot Encoding</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#preprocessdatasetmin_max_scaled_columns_train-and-min_max_scaled_columns_test">Min/Max Scaling</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#preprocessdatasetpca_train-and-pca_test">PCA</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#preprocessdatasetfeature_engineering_train-feature_engineering_test">Feature Engineering</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html#preprocessdatasetpreprocess_train-preprocess_test">Preprocess</a></li>
</ol>
</li>
</ol>
tts

In this function, you will take:

<ul>
<li>a dataset</li>
<li>the name of its label column</li>
<li>a percentage of the data to put into the test set</li>
<li>whether you should stratify on the label column</li>
<li>a random state to set the scikit-learn function</li>
</ul>
You will return features and labels for the training and test sets.

At a high level, you can separate the task into two subtasks. The first is splitting your dataset into both features and labels (by columns), and the second is splitting your dataset into training and test sets (by rows). You should use the scikit-learn&nbsp;train_test_split&nbsp;function but will have to write wrapper code around it based on the input values we give you.

Useful Resources

<ul>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html</a></li>
<li><a href="https://developers.google.com/machine-learning/crash-course/framing/ml-terminology">https://developers.google.com/machine-learning/crash-course/framing/ml-terminology</a></li>
<li><a href="https://stackoverflow.com/questions/40898019/what-is-the-difference-between-a-feature-and-a-label">https://stackoverflow.com/questions/40898019/what-is-the-difference-between-a-feature-and-a-label</a></li>
</ul>
INPUTS

<ul>
<li>dataset&nbsp;– a pandas DataFrame that contains some data</li>
<li>label_col&nbsp;– a string containing the name of the column that contains the&nbsp;label&nbsp;values (what our model wants to predict)</li>
<li>test_size&nbsp;– a float containing the decimal value of the percentage of the number of rows that the test set should be out of the dataset</li>
<li>should_stratify&nbsp;– a boolean (True&nbsp;or&nbsp;False) value indicating if the resulting train/test split should be stratified or not</li>
<li>random_state&nbsp;– an integer value to set the randomness of the function (useful for repeatability especially when autograding)</li>
</ul>
OUTPUTS

<ul>
<li>train_features&nbsp;– a pandas DataFrame that contains the train rows and the feature columns</li>
<li>test_features&nbsp;– a pandas DataFrame that contains the test rows and the feature columns</li>
<li>train_labels&nbsp;– a pandas DataFrame that contains the train rows and the label column</li>
<li>test_labels&nbsp;– a pandas DataFrame that contains the test rows and the label column</li>
</ul>
Function Skeleton

def tts(&nbsp; dataset: pd.DataFrame,

label_col: str,

test_size: float,

should_stratify: bool,

random_state: int) -&gt; tuple[pd.DataFrame,pd.DataFrame,pd.Series,pd.Series]:

<em># TODO</em>

return train_features,test_features,train_labels,test_labels

PreprocessDataset

The PreprocessDataset Class contains a code skeleton with nine methods for you to implement. Most methods will be split into two parts: one that will be run on the training dataset and one that will be run on the test dataset. In Data Science/Machine Learning, this is done to avoid something called&nbsp;<a href="https://machinelearningmastery.com/data-leakage-machine-learning/"><em>Data Leakage</em></a>.

For this assignment, we don’t expect you to understand the nuances of the concept, but we will have you follow principles that will minimize the chances of it occurring. You will accomplish this by splitting data into training and test datasets and processing those datasets in slightly different ways.

Generally, for everything you do in this project, and if you do any ML or Data Science work in the future, you should train/fit on the training data first, then predict/transform on the training and test data. That holds up for basic preprocessing steps like task 2 and for complex models like you will see in tasks 3 and 4.

For the purposes of this project, you should&nbsp;<strong>never</strong>&nbsp;train or fit on the test data (and more generally in any ML project) because your test data is expected to give you an understanding of how your model/predictions will perform on unseen data. If you fit even a preprocessing step to your test data, then you are either giving the model information about the test set it wouldn’t have about unseen data (if you combine train and test and fit to both), or you are providing a different preprocessing than the model is expecting (if you fit a different preprocessor to the test data), and your model would not be expected to perform well.

<strong>Note</strong>: You should train/fit using the train dataset; then, once you have a fit encoder/scaler/pca/model instance, you can transform/predict on the training and test data.

You will also notice that we are only preprocessing the Features and not the Labels. There are a few cases where preprocessing steps on labels may be helpful in modeling, but they are definitely more advanced and out of the scope of this introduction. Generally, you will not need to do any preprocessing to your labels beyond potentially encoding a string value (i.e., “Malware” or “Benign”) into an integer value (0 or 1), which is called&nbsp;<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html#sklearn.preprocessing.LabelEncoder"><em>Label Encoding</em></a>.

PreprocessDataset:__init__

Similar to the Task1&nbsp;simpleClass&nbsp;subtask you previously completed you will initialize the class by adding instance variables (add all the inputs to the class).

Useful Resources

<ul>
<li><a href="https://www.w3schools.com/python/python_classes.asp">https://www.w3schools.com/python/python_classes.asp</a></li>
</ul>
INPUTS

<ul>
<li>one_hot_encode_cols&nbsp;– a list of column names (strings) that should be one hot encoded by the one hot encode methods</li>
<li>min_max_scale_cols&nbsp;– a list of column names (strings) that should be min/max scaled by the min/max scaling methods</li>
<li>n_components&nbsp;– an int that contains the number of components that should be used in Principal Component Analysis</li>
<li>feature_engineering_functions&nbsp;– a dictionary that contains feature name and function to create that feature as a key value pair (example shown below)</li>
</ul>
Example of&nbsp;feature_engineering_functions:

def double_height(dataframe:pd.DataFrame):

return dataframe[“height”] * 2

&nbsp;

def half_height(dataframe:pd.DataFrame):

return dataframe[“height”] / 2

&nbsp;

feature_engineering_functions = {“double_height”:double_height,”half_height”:half_height}

Don’t worry about copying it we also have examples in the local test cases this is just provided as an illustration of what to expect in your function.

OUTPUTS

None, just assign all the input parameters to class variables.

Also per the instructions below, you’ll return here and create another instance variable: a scikit-learn&nbsp;OneHotEncoder&nbsp;with any Parameters you may need later.

Function Skeleton

def __init__(self,

one_hot_encode_cols:list[str],

min_max_scale_cols:list[str],

n_components:int,

feature_engineering_functions:dict

):

<em># TODO: Add any instance variables you may need to make your functions work</em>

return

PreprocessDataset:one_hot_encode_columns_train&nbsp;and&nbsp;one_hot_encode_columns_test

One Hot Encoding is the process of taking a column and returning a binary vector representing the various values within it. There is a separate function for the training and test datasets since they should be handled separately to avoid data leakage (see the 3rd link in Useful Resources for a little more info on how to handle them).

Pseudocode

one_hot_encode_columns_train()

<ol>
<li>In the&nbsp;PreprocessDataset&nbsp;__init__()&nbsp;method initialize an instance variable containing a scikit-learn&nbsp;OneHotEncoder&nbsp;with any parameters you may need.</li>
<li>Split&nbsp;train_features&nbsp;into two DataFrames: one with only the columns you want to one hot encode (using&nbsp;one_hot_encode_cols) and another with all the other columns.</li>
<li>Fit the&nbsp;OneHotEncoder&nbsp;using the DataFrame you split from&nbsp;train_features&nbsp;with the columns you want to encode.</li>
<li>Transform the DataFrame you split from&nbsp;train_features&nbsp;with the columns you want to encode using the fitted&nbsp;OneHotEncoder.</li>
<li>Create a DataFrame from the 2D array of data that the output from step 4 gave you, with column names in the form of&nbsp;columnName_categoryName&nbsp;(there should be an attribute in&nbsp;OneHotEncoder&nbsp;that can help you with this) and the same index that&nbsp;train_features&nbsp;had.</li>
<li>Concatenate the DataFrame you made in step 5 with the DataFrame of other columns from step 2.</li>
</ol>
one_hot_encode_columns_test()

<ol>
<li>Split&nbsp;test_features&nbsp;into two DataFrames: one with only the columns you want to one hot encode (usingone_hot_encode_cols) and another with all the other columns.</li>
<li>Transform the DataFrame you split from&nbsp;test_features&nbsp;with the columns you want to encode using the&nbsp;OneHotEncoder&nbsp;you fit in&nbsp;one_hot_encode_columns_train()</li>
<li>Create a DataFrame from the 2D array of data that the output from step 2 gave you, with column names in the form of&nbsp;columnName_categoryName&nbsp;(there should be an attribute in&nbsp;OneHotEncoder&nbsp;that can help you with this) and the same index that&nbsp;test_features&nbsp;had.</li>
<li>Concatenate the DataFrame you made in step 3 with the DataFrame of other columns from step 1.</li>
</ol>
Example Walkthrough (from Local Testing suite):

INPUTS:

one_hot_encode_cols

[“src_ip”,”protocol”]

Train Features

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip</strong></td>
<td><strong>protocol</strong></td>
<td><strong>bytes_in</strong></td>
<td><strong>bytes_out</strong></td>
<td><strong>time</strong></td>
</tr>
<tr>
<td>3</td>
<td>104.128.239.2</td>
<td>TCP</td>
<td>1054</td>
<td>9108</td>
<td>2024-12-20 09:15:42</td>
</tr>
<tr>
<td>1</td>
<td>103.31.4.0</td>
<td>TCP</td>
<td>3412</td>
<td>7567</td>
<td>2024-12-19 23:33:21</td>
</tr>
<tr>
<td>7</td>
<td>10.112.171.199</td>
<td>TCP</td>
<td>553</td>
<td>2331</td>
<td>2024-12-20 01:26:51</td>
</tr>
<tr>
<td>9</td>
<td>108.162.192.0</td>
<td>ICMP</td>
<td>8423</td>
<td>3805</td>
<td>2024-12-20 11:55:52</td>
</tr>
<tr>
<td>5</td>
<td>216.189.157.2</td>
<td>UDP</td>
<td>9328</td>
<td>7089</td>
<td>2024-12-20 20:50:30</td>
</tr>
<tr>
<td>0</td>
<td>103.21.244.0</td>
<td>UDP</td>
<td>2782</td>
<td>108</td>
<td>2024-12-20 11:16:23</td>
</tr>
<tr>
<td>4</td>
<td>45.58.56.3</td>
<td>TCP</td>
<td>6959</td>
<td>298</td>
<td>2024-12-20 15:30:56</td>
</tr>
<tr>
<td>2</td>
<td>108.162.192.0</td>
<td>UDP</td>
<td>8856</td>
<td>3510</td>
<td>2024-12-19 22:42:38</td>
</tr>
</tbody>
</table>
Test Features

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip</strong></td>
<td><strong>protocol</strong></td>
<td><strong>bytes_in</strong></td>
<td><strong>bytes_out</strong></td>
<td><strong>time</strong></td>
</tr>
<tr>
<td>8</td>
<td>10.130.94.70</td>
<td>TCP</td>
<td>8172</td>
<td>5321</td>
<td>2024-12-20 17:00:19</td>
</tr>
<tr>
<td>6</td>
<td>103.21.244.0</td>
<td>UDP</td>
<td>9871</td>
<td>7476</td>
<td>2024-12-20 03:16:40</td>
</tr>
</tbody>
</table>
Train DataFrames at each step:

2.

DataFrame with columns to encode:

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip</strong></td>
<td><strong>protocol</strong></td>
</tr>
<tr>
<td>3</td>
<td>104.128.239.2</td>
<td>TCP</td>
</tr>
<tr>
<td>1</td>
<td>103.31.4.0</td>
<td>TCP</td>
</tr>
<tr>
<td>7</td>
<td>10.112.171.199</td>
<td>TCP</td>
</tr>
<tr>
<td>9</td>
<td>108.162.192.0</td>
<td>ICMP</td>
</tr>
<tr>
<td>5</td>
<td>216.189.157.2</td>
<td>UDP</td>
</tr>
<tr>
<td>0</td>
<td>103.21.244.0</td>
<td>UDP</td>
</tr>
<tr>
<td>4</td>
<td>45.58.56.3</td>
<td>TCP</td>
</tr>
<tr>
<td>2</td>
<td>108.162.192.0</td>
<td>UDP</td>
</tr>
</tbody>
</table>
DataFrame with other columns:

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>bytes_in</strong></td>
<td><strong>bytes_out</strong></td>
<td><strong>time</strong></td>
</tr>
<tr>
<td>3</td>
<td>1054</td>
<td>9108</td>
<td>2024-12-20 09:15:42</td>
</tr>
<tr>
<td>1</td>
<td>3412</td>
<td>7567</td>
<td>2024-12-19 23:33:21</td>
</tr>
<tr>
<td>7</td>
<td>553</td>
<td>2331</td>
<td>2024-12-20 01:26:51</td>
</tr>
<tr>
<td>9</td>
<td>8423</td>
<td>3805</td>
<td>2024-12-20 11:55:52</td>
</tr>
<tr>
<td>5</td>
<td>9328</td>
<td>7089</td>
<td>2024-12-20 20:50:30</td>
</tr>
<tr>
<td>0</td>
<td>2782</td>
<td>108</td>
<td>2024-12-20 11:16:23</td>
</tr>
<tr>
<td>4</td>
<td>6959</td>
<td>298</td>
<td>2024-12-20 15:30:56</td>
</tr>
<tr>
<td>2</td>
<td>8856</td>
<td>3510</td>
<td>2024-12-19 22:42:38</td>
</tr>
</tbody>
</table>
4.

One Hot Encoded 2d array:

<table>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
5.

One Hot Encoded DataFrame with Index and Column Names

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip_10.112.171.199</strong></td>
<td><strong>src_ip_103.21.244.0</strong></td>
<td><strong>src_ip_103.31.4.0</strong></td>
<td><strong>src_ip_104.128.239.2</strong></td>
<td><strong>src_ip_108.162.192.0</strong></td>
<td><strong>src_ip_216.189.157.2</strong></td>
<td><strong>src_ip_45.58.56.3</strong></td>
<td><strong>protocol_ICMP</strong></td>
<td><strong>protocol_TCP</strong></td>
<td><strong>protocol_UDP</strong></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
6.

Final DataFrame with passthrough/other columns joined back

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip_10.112.171.199</strong></td>
<td><strong>src_ip_103.21.244.0</strong></td>
<td><strong>src_ip_103.31.4.0</strong></td>
<td><strong>src_ip_104.128.239.2</strong></td>
<td><strong>src_ip_108.162.192.0</strong></td>
<td><strong>src_ip_216.189.157.2</strong></td>
<td><strong>src_ip_45.58.56.3</strong></td>
<td><strong>protocol_ICMP</strong></td>
<td><strong>protocol_TCP</strong></td>
<td><strong>protocol_UDP</strong></td>
<td><strong>bytes_in</strong></td>
<td><strong>bytes_out</strong></td>
<td><strong>time</strong></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1054</td>
<td>9108</td>
<td>2024-12-20 09:15:42</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3412</td>
<td>7567</td>
<td>2024-12-19 23:33:21</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>553</td>
<td>2331</td>
<td>2024-12-20 01:26:51</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>8423</td>
<td>3805</td>
<td>2024-12-20 11:55:52</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>9328</td>
<td>7089</td>
<td>2024-12-20 20:50:30</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2782</td>
<td>108</td>
<td>2024-12-20 11:16:23</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>6959</td>
<td>298</td>
<td>2024-12-20 15:30:56</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>8856</td>
<td>3510</td>
<td>2024-12-19 22:42:38</td>
</tr>
</tbody>
</table>
Test DataFrames at each step:

1.

DataFrame with columns to encode:

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip</strong></td>
<td><strong>protocol</strong></td>
</tr>
<tr>
<td>8</td>
<td>10.130.94.70</td>
<td>TCP</td>
</tr>
<tr>
<td>6</td>
<td>103.21.244.0</td>
<td>UDP</td>
</tr>
</tbody>
</table>
DataFrame with other columns:

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>bytes_in</strong></td>
<td><strong>bytes_out</strong></td>
<td><strong>time</strong></td>
</tr>
<tr>
<td>8</td>
<td>8172</td>
<td>5321</td>
<td>2024-12-20 17:00:19</td>
</tr>
<tr>
<td>6</td>
<td>9871</td>
<td>7476</td>
<td>2024-12-20 03:16:40</td>
</tr>
</tbody>
</table>
2.

One Hot Encoded 2d array:

<table>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
3.

One Hot Encoded DataFrame with Index and Column Names

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip_10.112.171.199</strong></td>
<td><strong>src_ip_103.21.244.0</strong></td>
<td><strong>src_ip_103.31.4.0</strong></td>
<td><strong>src_ip_104.128.239.2</strong></td>
<td><strong>src_ip_108.162.192.0</strong></td>
<td><strong>src_ip_216.189.157.2</strong></td>
<td><strong>src_ip_45.58.56.3</strong></td>
<td><strong>protocol_ICMP</strong></td>
<td><strong>protocol_TCP</strong></td>
<td><strong>protocol_UDP</strong></td>
</tr>
<tr>
<td>8</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
</tr>
<tr>
<td>6</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>
4.

Final DataFrame with passthrough columns joined back

<table>
<tbody>
<tr>
<td><strong>Index</strong></td>
<td><strong>src_ip_10.112.171.199</strong></td>
<td><strong>src_ip_103.21.244.0</strong></td>
<td><strong>src_ip_103.31.4.0</strong></td>
<td><strong>src_ip_104.128.239.2</strong></td>
<td><strong>src_ip_108.162.192.0</strong></td>
<td><strong>src_ip_216.189.157.2</strong></td>
<td><strong>src_ip_45.58.56.3</strong></td>
<td><strong>protocol_ICMP</strong></td>
<td><strong>protocol_TCP</strong></td>
<td><strong>protocol_UDP</strong></td>
<td><strong>bytes_in</strong></td>
<td><strong>bytes_out</strong></td>
<td><strong>time</strong></td>
</tr>
<tr>
<td>8</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>8172</td>
<td>5321</td>
<td>2024-12-20 17:00:19</td>
</tr>
<tr>
<td>6</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>9871</td>
<td>7476</td>
<td>2024-12-20 03:16:40</td>
</tr>
</tbody>
</table>
<strong>Note:</strong>&nbsp;For the local tests and autograder use the column naming scheme of joining the previous column name and the column value with an underscore (similar to above where Type -&gt; Type_Fruit and Type_Vegetable)

<strong>Note 2:</strong>&nbsp;Since you should only be fitting your encoder on the training data, if there are values in your test set that are different than those in the training set, you will denote that with 0s. In the example above, let’s say we have a row in the test set with pizza, which is neither a fruit nor vegetable for the Type_Fruit and Type_Vegetable. It should result in a 0 for both columns. If you don’t handle these properly, you may get errors like&nbsp;Test Failed: Found unknown categories.

<strong>Note 3:</strong>&nbsp;You may be tempted to use the pandas function&nbsp;get_dummies&nbsp;to solve this task, but its a trap. It seems easier, but you will have to do a lot more work to make it handle a train/test split. So, we suggest you use scikit-learn’s&nbsp;OneHotEncoder.

Useful Resources

<ul>
<li><a href="https://www.educative.io/blog/one-hot-encoding">https://www.educative.io/blog/one-hot-encoding</a></li>
<li><a href="https://developers.google.com/machine-learning/data-prep/transform/transform-categorical">https://developers.google.com/machine-learning/data-prep/transform/transform-categorical</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder</a></li>
<li><a href="https://datascience.stackexchange.com/questions/103211/do-we-need-to-pre-process-both-the-test-and-train-data-set">https://datascience.stackexchange.com/questions/103211/do-we-need-to-pre-process-both-the-test-and-train-data-set</a></li>
</ul>
INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

a pandas DataFrame with the columns listed in&nbsp;one_hot_encode_cols&nbsp;one hot encoded and all other columns in the DataFrame unchanged

Function Skeleton

def one_hot_encode_columns_train(self,train_features:pd.DataFrame) -&gt; pd.DataFrame:

one_hot_encoded_dataset = pd.DataFrame()

return one_hot_encoded_dataset

def one_hot_encode_columns_test(self,test_features:pd.DataFrame) -&gt; pd.DataFrame:

one_hot_encoded_dataset = pd.DataFrame()

return one_hot_encoded_dataset

PreprocessDataset:min_max_scaled_columns_train&nbsp;and&nbsp;min_max_scaled_columns_test

Min/Max Scaling is a process to transform numerical features to a specific range, typically [0, 1], to ensure that input values are comparable (similar to how you may have heard of “normalizing” data) and is a crucial preprocessing step for many machine learning algos. In particular this standardization is essential for algorithms like linear regression, logistic regression, k-means, and neural networks, which can be sensitive to the scale of input features, whereas some algos like decision trees are less impacted.

By applying Min/Max Scaling, we prevent feature dominance, to ideally improve performance and accuracy of these algorithms and improve training convergence. It’s a recommended step to ensure your models are trained on consistent and standardized data.

For the provided assignment you should&nbsp;<strong>use the scikit-learn MinMaxScaler function</strong>&nbsp;(linked in the resources below) rather than attempting to implement your own scaling function.

The&nbsp;<em>rough</em>&nbsp;implementation of the scikit-learn function is provided below for educational purposes.

X_std = (X – X.min(axis=0)) / (X.max(axis=0) – X.min(axis=0))

X_scaled = X_std * (max – min) + min

Note: There are separate functions for the training and test datasets to help avoid data leakage between the test/train datasets. Please refer to the 3rd link in Useful Resources for more information on how to handle this – namely that we should still scale the test data based on our “knowledge” of the train dataset.

Example Dataframe:

<table>
<tbody>
<tr>
<td><strong>Item</strong></td>
<td><strong>Price</strong></td>
<td><strong>Count</strong></td>
<td><strong>Type</strong></td>
</tr>
<tr>
<td>Apples</td>
<td>1.99</td>
<td>7</td>
<td>Fruit</td>
</tr>
<tr>
<td>Broccoli</td>
<td>1.29</td>
<td>435</td>
<td>Vegtable</td>
</tr>
<tr>
<td>Bananas</td>
<td>0.99</td>
<td>123</td>
<td>Fruit</td>
</tr>
<tr>
<td>Oranges</td>
<td>2.79</td>
<td>25</td>
<td>Fruit</td>
</tr>
<tr>
<td>Pineapples</td>
<td>4.89</td>
<td>5234</td>
<td>Fruit</td>
</tr>
</tbody>
</table>
Example Min Max Scaled Dataframe (rounded to 4 decimal places):

<table>
<tbody>
<tr>
<td><strong>Item</strong></td>
<td><strong>Price</strong></td>
<td><strong>Count</strong></td>
<td><strong>Type</strong></td>
</tr>
<tr>
<td>Apples</td>
<td>0.2564</td>
<td>7</td>
<td>Fruit</td>
</tr>
<tr>
<td>Broccoli</td>
<td>0.0769</td>
<td>435</td>
<td>Vegtable</td>
</tr>
<tr>
<td>Bananas</td>
<td>0</td>
<td>123</td>
<td>Fruit</td>
</tr>
<tr>
<td>Oranges</td>
<td>0.4615</td>
<td>25</td>
<td>Fruit</td>
</tr>
<tr>
<td>Pineapples</td>
<td>1</td>
<td>5234</td>
<td>Fruit</td>
</tr>
</tbody>
</table>
<strong>Note:</strong>&nbsp;For the Autograder use the same column name as the original column (ex: Price -&gt; Price)

Useful Resources

<ul>
<li><a href="https://developers.google.com/machine-learning/data-prep/transform/normalization">https://developers.google.com/machine-learning/data-prep/transform/normalization</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler</a></li>
<li><a href="https://datascience.stackexchange.com/questions/103211/do-we-need-to-pre-process-both-the-test-and-train-data-set">https://datascience.stackexchange.com/questions/103211/do-we-need-to-pre-process-both-the-test-and-train-data-set</a></li>
</ul>
INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

a pandas DataFrame with the columns listed in&nbsp;min_max_scale_cols&nbsp;min/max scaled and all other columns in the DataFrame unchanged

Function Skeleton

def min_max_scaled_columns_train(self,train_features:pd.DataFrame) -&gt; pd.DataFrame:

min_max_scaled_dataset = pd.DataFrame()

return min_max_scaled_dataset

def min_max_scaled_columns_test(self,test_features:pd.DataFrame) -&gt; pd.DataFrame:

min_max_scaled_dataset = pd.DataFrame()

return min_max_scaled_dataset

PreprocessDataset:pca_train&nbsp;and&nbsp;pca_test

Principal Component Analysis is a dimensionality reduction technique (column reduction). It aims to take the variance in your input columns and map the columns into N columns that contain as much of the variance as it can. This technique can be useful if you are trying to train a model faster and has some more advanced uses, especially when training models on data which has many columns but few rows. There is a separate function for the training and test datasets because they should be handled separately to avoid data leakage (see the 3rd link in Useful Resources for a little more info on how to handle them).

<strong>Note 1:</strong>&nbsp;For the local tests and autograder, use the column naming scheme of column names: component_1, component_2 .. component_n for the&nbsp;n_components&nbsp;passed into the&nbsp;__init__&nbsp;method.

<strong>Note 2:</strong>&nbsp;For your PCA outputs to match the local tests and autograder, make sure you set the seed using a random state of 0 when you initialize the PCA function.

<strong>Note 3:</strong>&nbsp;Since PCA does not work with NA values, make sure you drop any columns that have NA values before running PCA.

Useful Resources

<ul>
<li><a href="https://builtin.com/data-science/step-step-explanation-principal-component-analysis">https://builtin.com/data-science/step-step-explanation-principal-component-analysis</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA">https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA</a></li>
<li><a href="https://datascience.stackexchange.com/questions/103211/do-we-need-to-pre-process-both-the-test-and-train-data-set">https://datascience.stackexchange.com/questions/103211/do-we-need-to-pre-process-both-the-test-and-train-data-set</a></li>
</ul>
INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

a pandas DataFrame with the generated pca values and using column names: component_1, component_2 .. component_n

Function Skeleton

def pca_train(self,train_features:pd.DataFrame) -&gt; pd.DataFrame:

<em># TODO: Read the function description in https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html and implement the function as described</em>

pca_dataset = pd.DataFrame()

return pca_dataset

&nbsp;

def pca_test(self,test_features:pd.DataFrame) -&gt; pd.DataFrame:

<em># TODO: Read the function description in https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task2.html and implement the function as described</em>

pca_dataset = pd.DataFrame()

return pca_dataset

PreprocessDataset:feature_engineering_train,&nbsp;feature_engineering_test

Feature Engineering is a process of using domain knowledge (physics, geometry, sports statistics, business metrics, etc.) to create new features (columns) out of the existing data. This could mean creating an area feature when given the length and width of a triangle or extracting the major and minor version number from a software version or more complex logic depending on the scenario.

In cybersecurity in particular, feature engineering is crucial for using domain expert’s (e.g. a security analyst) experience to identify anomalous behavior that might signify a security breach. This could involve creating features that represent deviations from established baselines, such as unusual file access patterns, unexpected network connections, or sudden spikes in CPU usage. These anomaly-based features can help distinguish malicious activity from normal system operations, but the system does not know what data patterns mean anomalous off-hand – that is where you as the domain expert can help by creating features.

These methods utilize a dictionary,&nbsp;feature_engineering_functions,&nbsp;<strong>passed to the class constructor (</strong>__init__<strong>)</strong>. This dictionary defines how to generate new features:

<ol>
<li><strong>Keys:</strong>&nbsp;Strings representing new column names.</li>
<li><strong>Values:</strong>&nbsp;Functions that:
<ul>
<li>Take a DataFrame as input.</li>
<li>Return a Pandas Series (the new column’s values).</li>
</ul>
</li>
</ol>
<strong>Example of what&nbsp;<em>could</em>&nbsp;be passed as the&nbsp;</strong>feature_engineering_functions<strong>&nbsp;dictionary to&nbsp;</strong>__init__<strong>:</strong>

import pandas as pd

def double_height(dataframe: pd.DataFrame) -&gt; pd.Series:

return dataframe[“height”] * 2

&nbsp;

def half_height(dataframe: pd.DataFrame) -&gt; pd.Series:

return dataframe[“height”] / 2

&nbsp;

example_feature_engineering_functions = {

“double_height”: double_height, <em># Note that functions in python can be passed around and used just like data!</em>

“half_height”: half_height

}

&nbsp;

<em># and the class may be been created like this…</em>

<em># preprocessor = PreprocessDataset(…, feature_engineering_functions=example_feature_engineering_functions, …)</em>

In particular for this method, you will be taking in a dictionary with a column name and a function that takes in a DataFrame and returns a column. You’ll be using that to create a new column with the name in the dictionary key. Therefore if you were given the above functions, you would create two new columns named “double_height” and “half_height” in your Dataframe.

Useful Resources

<ul>
<li><a href="https://en.wikipedia.org/wiki/Feature_engineering">https://en.wikipedia.org/wiki/Feature_engineering</a></li>
<li><a href="https://www.geeksforgeeks.org/what-is-feature-engineering/">https://www.geeksforgeeks.org/what-is-feature-engineering/</a></li>
<li><a href="https://www.geeksforgeeks.org/passing-function-as-an-argument-in-python/">Passing Function as an Argument in Python – GeeksforGeeks</a></li>
</ul>
INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

a pandas dataframe with the features described in&nbsp;feature_engineering_train&nbsp;and&nbsp;feature_engineering_test&nbsp;added as new columns and all other columns in the dataframe unchanged

Function Skeleton

def feature_engineering_train(self,train_features:pd.DataFrame) -&gt; pd.DataFrame:

feature_engineered_dataset = pd.DataFrame()

return feature_engineered_dataset

def feature_engineering_test(self,test_features:pd.DataFrame) -&gt; pd.DataFrame:

feature_engineered_dataset = pd.DataFrame()

return feature_engineered_dataset

PreprocessDataset:preprocess_train,&nbsp;preprocess_test

Now, we will put three of the above methods together into a preprocess function. This function will take in a dataset and perform&nbsp;<strong>encoding</strong>,&nbsp;<strong>scaling</strong>, and&nbsp;<strong>feature engineering</strong>&nbsp;using the above methods and their respective columns. You should&nbsp;<strong>not</strong>&nbsp;perform PCA for this function.

Useful Resources

See resources for one hot encoding, min/max scaling and feature engineering above

INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

a pandas dataframe for both test and train features with the columns in&nbsp;one_hot_encode_cols&nbsp;encoded, the columns in&nbsp;min_max_scale_cols&nbsp;scaled and the columns described in&nbsp;feature_engineering_functions&nbsp;engineered.&nbsp;<strong>You do not need to use PCA here</strong>.

Function Skeleton

def preprocess_train(self,train_features:pd.DataFrame) -&gt; pd.DataFrame:

train_features = pd.DataFrame()

return train_features

&nbsp;

def preprocess_test(self,test_features:pd.DataFrame) -&gt; pd.DataFrame:

test_features = pd.DataFrame()

return test_features

&nbsp;

Task 3

In Task 2 you learned how to split a dataset into training and testing components. Now it’s time to learn about using a K-means model. We will run a basic model on the data to cluster files (rows) with similar attributes together. We will use an unsupervised model.

<strong>Theory</strong>

An&nbsp;<a href="https://en.wikipedia.org/wiki/Unsupervised_learning">unsupervised model</a>&nbsp;has no label column. By constrast, in&nbsp;<a href="https://en.wikipedia.org/wiki/Supervised_learning">supervised learning</a>&nbsp;(which you’ll see in Task 4) the data has features and targets/labels. These labels are effectively an answer key to the data in the feature columns. You don’t have this answer key in unsupervised learning, instead you’re working on data without labels. You’ll need to choose algorithms that can learn from the data, exclusively, without the benefit of lablels.

We start with&nbsp;<a href="https://en.wikipedia.org/wiki/K-means_clustering">K-means</a>&nbsp;because it is simple to understand the algorithm. For the Mathematics people, you can look at the underlying data structure,&nbsp;<a href="https://en.wikipedia.org/wiki/Voronoi_diagram">a Voronoi diagram</a>. Based on squared&nbsp;<a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidian distances</a>, K-means creates clusters of similar datapoints. Each cluster has a centroid. The idea is that for each sample, it’s associated/clustered with the centroid that is the “closest.”

Closest is an interesting concept in higher dimensions. You can think of each feature in a dataset as a dimension in the data. If it’s 2d or 3d, we can visualize it easily. Concepts of distance are clear in 2d and 3d, and they work similarly in 4+d.

If you read the Wikipedia articles for K-means you’ll see a discussion of the use of “squared Euclidean distances” in K-means. This is compared with simple Euclidean distances in the Weber problem, and better approaches resulting from k-medians and k-mediods is discussed.

Please use scikit-learn to create the model and Yellowbrick to determine the optimal value of k for the dataset.

So far, we have functions to split the data and preprocess it. Now, we will run a basic model on the data to cluster files (rows) with similar attributes together. We will use an unsupervised model (model with no label column), K-means. Again, use scikit-learn to create the model and Yellowbrick to determine the optimal value of k for the dataset.

Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details about submitting your work.

Useful Links:

<ul>
<li><a href="https://developers.google.com/machine-learning/clustering/overview">Clustering – Google Developers</a></li>
<li><a href="https://developers.google.com/machine-learning/clustering/clustering-algorithms">Clustering Algorithms – Google Developers</a></li>
<li><a href="https://developers.google.com/machine-learning/glossary#k-means">Kmeans – Google Developers</a></li>
</ul>
Deliverables:

<ul>
<li>Complete the KmeansClustering class in task3.py.</li>
<li>For this task we have released a local test suite please set that up and use it to debug your function.</li>
<li>Submit task3.py to Gradescope when you pass all local tests. Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details.</li>
</ul>
Local Test Dataset Information

For this task the local test dataset we are using is the NATICUSdroid dataset, which contains 86 columns of data related to android permissions used by benign and malicious Android applications released between 2010 and 2019. For more information such as the introductory paper and the Citations/Acknowledgements you can view the&nbsp;<a href="https://archive.ics.uci.edu/dataset/722/naticusdroid+android+permissions+dataset">dataset</a>&nbsp;site in the UCI ML repository. In this specific case clustering can be a useful tool to group apps that request similar permissions together. The team that created this dataset hypothesized that malicious apps would exhibit distinct patterns in the types of permissions they request compared to benign apps. This difference in permission request patterns could potentially be used to distinguish between malicious and benign applications.

Instructions:

The Task3.py File has function skeletons that you will complete with Python code. You will mostly be using the pandas, Yellowbrick and scikit-learn libraries. The goal of each of these functions is to give you familiarity with the applied concepts of Unsupervised Learning. See information about the function’s Inputs, Outputs and Skeletons below.

KmeansClustering

The KmeansClustering Class contains a code skeleton with 4 methods for you to implement.

<strong>Note</strong>: You should train/fit using the train dataset then once you have a Yellowbrick/K-means model instance you can transform/predict on the training and test data.

KmeansClustering:__init__

Similar to Task 1, you will initialize the class by adding instance variables as needed.

Useful Resources

<ul>
<li><a href="https://www.w3schools.com/python/python_classes.asp">https://www.w3schools.com/python/python_classes.asp</a></li>
</ul>
INPUTS

<ul>
<li>random_state&nbsp;– an integer that should be used to set the scikit-learn randomness so the model results will be repeatable which is required for the tests and autograder</li>
</ul>
OUTPUTS

None

Function Skeleton

def __init__(self,

random_state: int

):

<em># TODO: Add any state variables you may need to make your functions work</em>

pass

KmeansClustering:kmeans_train

Kmeans Clustering is a process of grouping together similar rows together and assigning them to a cluster. For this method you will use the training data to fit an optimal K-means cluster on the data.

To help you get started we have provided a list of subtasks to complete for this task:

<ol>
<li>Initialize a scikit-learn K-means model using random_state from the&nbsp;__init__&nbsp;method and setting n_init = 10.</li>
<li>Try to find the best “k” to use for the KMeans Clustering.
<ul>
<li>Initialize a Yellowbrick KElbowVisualizer with the K-means model.</li>
<li>Use that visualizer to search for the optimal value of k [between 1 (inclusive) and 10, (exclusive) in mathmatical expression that would be [1,10)].</li>
<li>Use the provided resources to understand how to interpret the visualization</li>
</ul>
</li>
<li>Train the KElbowVisualizer on the training data and determine the optimal k value.</li>
<li>Now, train a K-means model with the proper initialization for that optimal value of k</li>
<li>Return the cluster ids for each row of the training set as a list.</li>
</ol>
Useful Resources

<ul>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans">https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans</a></li>
<li><a href="https://www.scikit-yb.org/en/latest/api/cluster/elbow.html">https://www.scikit-yb.org/en/latest/api/cluster/elbow.html</a></li>
</ul>
INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
</ul>
OUTPUTS

a list of cluster ids that the K-means model has assigned for each row in the train dataset

Function Skeleton

def kmeans_train(self,train_features:pd.DataFrame) -&gt; list:

cluster_ids = list()

return cluster_ids

KmeansClustering:kmeans_test

K-means clustering is a process of grouping together similar rows together and assigning them to a cluster. For this method you will use the training data to fit an optimal K-means cluster on the test data.

To help you get started, we have provided a list of subtasks to complete for this task:

<ol>
<li>Use a model similar to the one you trained in the&nbsp;kmeans_train&nbsp;method to generate cluster ids for each row of the test dataset. You should either (1) reuse the same model from kmeans_train or (2) train a new model in the test method using the training data.</li>
<li>Return the cluster ids for each row of the test set as a list.</li>
</ol>
Useful Resources

<ul>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans">https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans</a></li>
<li><a href="https://www.scikit-yb.org/en/latest/api/cluster/elbow.html">https://www.scikit-yb.org/en/latest/api/cluster/elbow.html</a></li>
</ul>
INPUTS

<ul>
<li>Use the needed instance variables you set in the&nbsp;__init__&nbsp;method</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

a list of cluster ids that the K-means model has assigned for each row in the test dataset

Function Skeleton

def kmeans_test(self,test_features:pd.DataFrame) -&gt; list:

cluster_ids = list()

return cluster_ids

KmeansClustering:train_add_kmeans_cluster_id_feature,&nbsp;test_add_kmeans_cluster_id_feature

Using the two methods you completed above (kmeans_train&nbsp;and&nbsp;kmeans_test) you will add a new feature(column) to the training and test dataframes. This is similar to the feature engineering method in Task 2 where you appended new columns onto an existing dataframe.

To do this, use the output of the methods (the list of cluster ids you return) from the corresponding train or test method and add it as a new column named&nbsp;kmeans_cluster_id&nbsp;in the input dataframe, then return the full dataframe.

Useful Resources

INPUTS

Use the needed instance variables you set in the&nbsp;__init__&nbsp;method and the&nbsp;kmeans_train&nbsp;and&nbsp;kmeans_test&nbsp;methods you wrote above to produce the needed output.

<ul>
<li>train_features&nbsp;– a dataset split by a function similar to tts which should be used in the training/fitting steps</li>
<li>test_features&nbsp;– a dataset split by a function similar to tts which should be used in the test steps</li>
</ul>
OUTPUTS

A pandas dataframe with the&nbsp;kmeans_cluster_id&nbsp;added as a feature and all other input columns unchanged, for each of the two methods&nbsp;train_add_kmeans_cluster_id_feature&nbsp;and&nbsp;test_add_kmeans_cluster_id_feature.

Function Skeleton

def train_add_kmeans_cluster_id_feature(self,train_features:pd.DataFrame) -&gt; pd.DataFrame:

output_df = pd.DataFrame()

return output_df

&nbsp;

def test_add_kmeans_cluster_id_feature(self,test_features:pd.DataFrame) -&gt; pd.DataFrame:

output_df = pd.DataFrame()

return output_df

&nbsp;

<strong>&nbsp;</strong>

<strong>&nbsp;</strong>

<strong>&nbsp;</strong>

<strong>&nbsp;</strong>

<strong>&nbsp;</strong>

<strong>&nbsp;</strong>

<strong>&nbsp;</strong>

<strong>Task 4 </strong>

Now let’s try a few supervised classification models:

<ul>
<li>A naive model you’ll build yourself</li>
<li>Logistic Regression</li>
<li>Random Forest</li>
<li>Gradient Boosting</li>
</ul>
We have chosen a few commonly used models for you to use here, but there are many options. In the real world, specific algorithms may fit a specific dataset better than other algorithms.

You won’t be doing any hyperparameter tuning yet, so you can better focus on writing the basic code. You will:

<ul>
<li>Train a model using the training set.</li>
<li>Predict on the training/test sets.</li>
<li>Calculate performance metrics.</li>
<li>Return a&nbsp;ModelMetrics&nbsp;object and trained scikit-learn model from each model function.</li>
</ul>
(Note on feature importance: You should use RFE for determining feature importance of your Logistic Regression model, but do NOT use RFE for your Random Forest or Gradient Boosting models to determine feature importance. Please use their built-in values for this.)

Useful Links:

<ul>
<li><a href="https://scikit-learn.org/stable/index.html">scikit-learn: machine learning in Python — scikit-learn 1.2.1 documentation</a></li>
<li><a href="https://developers.google.com/machine-learning/crash-course/training-and-test-sets/video-lecture">Training and Test Sets – Machine Learning – Google Developers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff">Bias–variance tradeoff – Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Overfitting">Overfitting – Wikipedia</a></li>
<li><a href="https://builtin.com/machine-learning/classification-machine-learning">An Introduction to Classification in Machine Learning – builtin</a></li>
<li><a href="https://www.datacamp.com/blog/classification-machine-learning">Classification in Machine Learning: An Introduction – DataCamp</a></li>
</ul>
Deliverables:

<ul>
<li>Complete the functions and methods in task4.py</li>
<li>For this task we have released a local test suite please set that up and use it to debug your function.</li>
<li>Submit task4.py to Gradescope when you pass all local tests. Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details.</li>
</ul>
Local Test Dataset Information

For this task the local test dataset we are using is the NATICUSdroid dataset, which contains 86 columns of data related to android permissions used by benign and malicious Android applications released between 2010 and 2019. For more information such as the introductory paper and the Citations/Acknowledgements you can view the&nbsp;<a href="https://archive.ics.uci.edu/dataset/722/naticusdroid+android+permissions+dataset">dataset</a>&nbsp;site in the UCI ML repository. If you look at the&nbsp;<a href="https://www.ndss-symposium.org/wp-content/uploads/NDSS2021posters_paper_12.pdf">online poster</a>&nbsp;for the paper that the dataset creators wrote from their research, they trained a variety of different models including Random Forest, Logistic Regression and XGBoost and calculated a variety of metrics related to training and detection performance. In this task we will guide you through training ML models and calculating performance metrics to compare the predictive abilities of different models.

Instructions:

The Task4.py File has function skeletons that you will complete with Python code (mostly using the pandas and scikit-learn libraries).

The goal of each of these functions is to give you familiarity with the applied concepts of training a model, using it to score records and calculating performance metrics for it. See information about the function inputs, outputs and skeletons below.

Table of contents

<ol>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task4.html#ModelMetrics">ModelMetrics</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task4.html#calculate_naive_metrics">calculate_naive_metrics</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task4.html#calculate_logistic_regression_metrics">calculate_logistic_regression_metrics</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task4.html#calculate_random_forest_metrics">calculate_random_forest_metrics</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/Task4.html#calculate_gradient_boosting_metrics">calculate_gradient_boosting_metrics</a></li>
</ol>
ModelMetrics

<ul>
<li>In order to simplify the autograding we have created a class that will hold the metrics and feature importances for a model you trained.</li>
<li>You should not modify this class but are expected to use it in your return statements.</li>
<li>This means you put your training and test metrics dictionaries and feature importance DataFrames inside a&nbsp;ModelMetrics&nbsp;object for the autograder to handle. This is for each of the Logistic Regression, Gradient Boosting and Random Forest models you will create.</li>
<li>You do not need to return a feature importance DataFrame in the&nbsp;ModelMetrics&nbsp;value for the naive model you will create, just return None in that position of the return statement, as the given code does.</li>
</ul>
calculate_naive_metrics

A Naive model is a very simple model/prediction that can help to frame how well a more sophisticated model is doing. At best, such a model has random competence at predicting things. At worst, it’s wrong all the time.

Since a naive model is incredibly basic (often a constant or randomly selected result), we can expect that any more sophisticated model that we train should outperform it. If the naive Model beats our trained model, it can mean that additional data (rows or columns) is needed in the dataset to improve our model. It can also mean that the dataset doesn’t have a strong enough signal for the target we want to predict.

<strong>In this function, you’ll implement a simple model that always predicts a constant (function-provided) number, regardless of the input values.</strong>&nbsp;Specifically, you’ll use a given constant integer, provided as the parameter&nbsp;naive_assumption, as the model’s prediction. This means the model will always output this constant value, without considering the actual data. Afterward, you will calculate four metrics—accuracy, recall, precision, and F1-score—for both the training and test datasets.

[1] Refer to the resources below.

Useful Resources

<ul>
<li><a href="https://machinelearningmastery.com/how-to-develop-and-evaluate-naive-classifier-strategies-using-probability/">https://machinelearningmastery.com/how-to-develop-and-evaluate-naive-classifier-strategies-using-probability/</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score</a></li>
</ul>
INPUTS

<ul>
<li>train_features&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>test_features&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>train_targets&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>test_targets&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>naive_assumption&nbsp;– an integer that should be used as the result from the naive model you will create</li>
</ul>
OUTPUTS

A completed&nbsp;ModelMetrics&nbsp;object with a training and test metrics dictionary with each one of the metrics&nbsp;<strong>rounded to 4 decimal places</strong>

Function Skeleton

def calculate_naive_metrics(train_features:pd.DataFrame, test_features:pd.DataFrame, train_targets:pd.Series, test_targets:pd.Series, naive_assumption:int) -&gt; ModelMetrics:

train_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0

}

test_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0

}

naive_metrics = ModelMetrics(“Naive”,train_metrics,test_metrics,None)

return naive_metrics

calculate_logistic_regression_metrics

A logistic regression model is a simple and more explainable statistical model that can be used to estimate the probability of an event (<a href="https://www.statisticshowto.com/log-odds/">log-odds</a>). At a high level, a logistic regression model uses data in the training set to estimate a column’s weight in a linear approximation function. Conceptually this is similar to estimating&nbsp;m&nbsp;for each column in the line formula you probably know well from geometry:&nbsp;y = m*x + b. If you are interested in learning more,&nbsp;<a href="https://en.wikipedia.org/wiki/Logistic_regression">you can read up on the math</a>&nbsp;behind how this works. For this project, we are more focused on showing you how to apply these models, so you can simply use a scikit-learn Logistic Regression model in your code.

For this task use scikit-learn’s LogisticRegression class and complete the following subtasks:

<ul>
<li>Train a Logistic Regression model (initialized using the kwargs passed into the function)</li>
<li>Predict scores for training and test datasets and calculate the 7 metrics listed below for the training and test datasets using predictions from the fit model. (All rounded to 4 decimal places)
<ul>
<li>accuracy</li>
<li>recall</li>
<li>precision</li>
<li>fscore</li>
<li>false positive rate (fpr)</li>
<li>false negative rate (fnr)</li>
<li>Area Under the Curve of Receiver Operating Characteristics Curve (roc_auc)</li>
</ul>
</li>
<li>Use RFE to select the top 10 features</li>
<li>Train a Logistic Regression model using these selected features (initialized using the kwargs passed into the function)</li>
<li>Create a Feature Importance DataFrame from the model trained on the top 10 features:
<ul>
<li>Use the top 10 features sort&nbsp;<strong>by absolute value</strong>&nbsp;of the coefficient from biggest to smallest.</li>
<li>Make sure you use the same feature and importance column names as set in ModelMetrics in feat_name_col [Feature] and imp_col [Importance].</li>
<li>Round the importances to 4 decimal places (<strong>do this step after you have sorted by Importance</strong>)</li>
<li>Reset the index to 0-9. You can do this the same way you did in task1.</li>
</ul>
</li>
</ul>
<strong>NOTE:</strong>&nbsp;Make sure you use the predicted probabilities for roc auc

Useful Resources

<ul>
<li><a href="https://stats.libretexts.org/Bookshelves/Introductory_Statistics/OpenIntro_Statistics_(Diez_et_al)./08%3A_Multiple_and_Logistic_Regression/8.04%3A_Introduction_to_Logistic_Regression">https://stats.libretexts.org/Bookshelves/Introductory_Statistics/OpenIntro_Statistics_(Diez_et_al)./08%3A_Multiple_and_Logistic_Regression/8.04%3A_Introduction_to_Logistic_Regression</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression">https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score</a></li>
<li><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html</a></li>
</ul>
INPUTS

The first 4 are similar to the&nbsp;tts&nbsp;function you created in Task 2:

<ul>
<li>train_features&nbsp;– a Pandas Dataframe with training features</li>
<li>test_features&nbsp;– a Pandas Dataframe with test features</li>
<li>train_targets&nbsp;– a Pandas Dataframe with training targets</li>
<li>test_targets&nbsp;– a Pandas Dataframe with test targets</li>
<li>logreg_kwargs&nbsp;– a dictionary with keyword arguments that can be passed directly to the scikit-learn Logistic Regression class</li>
</ul>
OUTPUTS

<ul>
<li>A completed&nbsp;ModelMetrics&nbsp;object with a training and test metrics dictionary with each one of the metrics&nbsp;<strong>rounded to 4 decimal places</strong></li>
<li>A scikit-learn Logistic Regression model object fit on the training set</li>
</ul>
Function Skeleton

def calculate_logistic_regression_metrics(train_features:pd.DataFrame, test_features:pd.DataFrame, train_targets:pd.Series, test_targets:pd.Series, logreg_kwargs) -&gt; tuple[ModelMetrics,LogisticRegression]:

model = LogisticRegression()

train_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0,

“fpr” : 0,

“fnr” : 0,

“roc_auc” : 0

}

test_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0,

“fpr” : 0,

“fnr” : 0,

“roc_auc” : 0

}

&nbsp;

log_reg_importance = pd.DataFrame()

log_reg_metrics = ModelMetrics(“Logistic Regression”,train_metrics,test_metrics,log_reg_importance)

&nbsp;

return log_reg_metrics,model

Example of Feature Importance DataFrame

<table>
<tbody>
<tr>
<td></td>
<td><strong>Feature</strong></td>
<td><strong>Importance</strong></td>
</tr>
<tr>
<td>0</td>
<td>android.permission.REQUEST_INSTALL_PACKAGES</td>
<td>-5.5969</td>
</tr>
<tr>
<td>1</td>
<td>android.permission.READ_PHONE_STATE</td>
<td>5.1587</td>
</tr>
<tr>
<td>2</td>
<td>android.permission.android.permission.READ_PHONE_STATE</td>
<td>-4.7923</td>
</tr>
<tr>
<td>3</td>
<td>com.anddoes.launcher.permission.UPDATE_COUNT</td>
<td>-4.7506</td>
</tr>
<tr>
<td>4</td>
<td>com.samsung.android.providers.context.permission.WRITE_USE_APP_FEATURE_SURVEY</td>
<td>-4.4933</td>
</tr>
<tr>
<td>5</td>
<td>com.google.android.finsky.permission.BIND_GET_INSTALL_REFERRER_SERVICE</td>
<td>-4.4831</td>
</tr>
<tr>
<td>6</td>
<td>com.google.android.c2dm.permission.RECEIVE</td>
<td>-4.2781</td>
</tr>
<tr>
<td>7</td>
<td>android.permission.FOREGROUND_SERVICE</td>
<td>-4.1966</td>
</tr>
<tr>
<td>8</td>
<td>android.permission.USE_FINGERPRINT</td>
<td>-3.9239</td>
</tr>
<tr>
<td>9</td>
<td>android.permission.INTERNET</td>
<td>-2.7991</td>
</tr>
</tbody>
</table>
calculate_random_forest_metrics

A Random Forest model is a more complex model than the naive and Logistic Regression Models you have trained so far. It can still be used to estimate the probability of an event, but achieves this using a different underlying structure:&nbsp;<a href="https://en.wikipedia.org/wiki/Decision_tree_learning">a tree-based model</a>.

Conceptually, this looks a lot like many if/else statements chained together into a “tree”. A Random Forest expands on this and trains different trees with different subsets of the data and starting conditions. It does this to get a better estimate than a single tree would give. For this project, we are more focused on showing you how to apply these models, so you can simply use the scikit-learn Random Forest model in your code.

For this task use scikit-learn’s Random Forest Classifier class and complete the following subtasks:

<ul>
<li>Train a Random Forest model (initialized using the kwargs passed into the function)</li>
<li>Predict scores for training and test datasets and calculate the 7 metrics listed below for the training and test datasets using predictions from the fit model. (All rounded to 4 decimal places)
<ul>
<li>accuracy</li>
<li>recall</li>
<li>precision</li>
<li>fscore</li>
<li>false positive rate (fpr)</li>
<li>false negative rate (fnr)</li>
<li>Area Under the Curve of Receiver Operating Characteristics Curve (roc_auc)</li>
</ul>
</li>
<li>Create a Feature Importance DataFrame from the trained model:
<ul>
<li><strong>Do Not Use RFE for feature selection</strong></li>
<li>Use the top 10 features selected by the built in method (sorted from biggest to smallest)</li>
<li>Make sure you use the same feature and importance column names as ModelMetrics shows in feat_name_col [Feature] and imp_col [Importance]</li>
<li>Round the importances to 4 decimal places (<strong>do this step after you have sorted by Importance</strong>)</li>
<li>Reset the index to 0-9 you can do this the same way you did in task1</li>
</ul>
</li>
</ul>
<strong>NOTE:</strong>&nbsp;Make sure you use the predicted probabilities for roc auc

Useful Resources

<ul>
<li><a href="https://blog.dataiku.com/tree-based-models-how-they-work-in-plain-english">https://blog.dataiku.com/tree-based-models-how-they-work-in-plain-english</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score</a></li>
<li><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html</a></li>
</ul>
INPUTS

<ul>
<li>train_features&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>test_features&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>train_targets&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>test_targets&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>rf_kwargs&nbsp;– a dictionary with keyword arguments that can be passed directly to the scikit-learn RandomForestClassifier class</li>
</ul>
OUTPUTS

<ul>
<li>A completed&nbsp;ModelMetrics&nbsp;object with a training and test metrics dictionary with each one of the metrics&nbsp;<strong>rounded to 4 decimal places</strong></li>
<li>An scikit-learn Random Forest model object fit on the training set</li>
</ul>
Function Skeleton

def calculate_random_forest_metrics(train_features:pd.DataFrame, test_features:pd.DataFrame, train_targets:pd.Series, test_targets:pd.Series, rf_kwargs) -&gt; tuple[ModelMetrics,RandomForestClassifier]:

&nbsp;

model = RandomForestClassifier()

&nbsp;

train_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0,

“fpr” : 0,

“fnr” : 0,

“roc_auc” : 0

}

&nbsp;

test_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0,

“fpr” : 0,

“fnr” : 0,

“roc_auc” : 0

}

&nbsp;

rf_importance = pd.DataFrame()

rf_metrics = ModelMetrics(“Random Forest”,train_metrics,test_metrics,rf_importance)

&nbsp;

return rf_metrics,model

Example of Feature Importance DataFrame

<table>
<tbody>
<tr>
<td></td>
<td><strong>Feature</strong></td>
<td><strong>Importance</strong></td>
</tr>
<tr>
<td>0</td>
<td>android.permission.READ_PHONE_STATE</td>
<td>0.1871</td>
</tr>
<tr>
<td>1</td>
<td>com.google.android.c2dm.permission.RECEIVE</td>
<td>0.1165</td>
</tr>
<tr>
<td>2</td>
<td>android.permission.RECEIVE_BOOT_COMPLETED</td>
<td>0.1036</td>
</tr>
<tr>
<td>3</td>
<td>com.android.launcher.permission.INSTALL_SHORTCUT</td>
<td>0.1004</td>
</tr>
<tr>
<td>4</td>
<td>android.permission.ACCESS_COARSE_LOCATION</td>
<td>0.0921</td>
</tr>
<tr>
<td>5</td>
<td>android.permission.ACCESS_FINE_LOCATION</td>
<td>0.0531</td>
</tr>
<tr>
<td>6</td>
<td>android.permission.GET_TASKS</td>
<td>0.0462</td>
</tr>
<tr>
<td>7</td>
<td>android.permission.SYSTEM_ALERT_WINDOW</td>
<td>0.0433</td>
</tr>
<tr>
<td>8</td>
<td>com.android.vending.BILLING</td>
<td>0.026</td>
</tr>
<tr>
<td>9</td>
<td>android.permission.WRITE_SETTINGS</td>
<td>0.0236</td>
</tr>
</tbody>
</table>
calculate_gradient_boosting_metrics

A Gradient Boosted model is more complex than the Naive and Logistic Regression models and similar in structure to the Random Forest model you just trained. A Gradient Boosted model expands on the tree-based model by using its additional trees to predict the errors from the previous tree. For this project, we are more focused on showing you how to apply these models, so you can simply use the scikit-learn Gradient Boosted Model in your code.

For this task use scikit-learn’s Gradient Boosting Classifier class and complete the following subtasks:

<ul>
<li>Train a Gradient Boosted model (initialized using the kwargs passed into the function)</li>
<li>Predict scores for training and test datasets and calculate the 7 metrics listed below for the training and test datasets using predictions from the fit model. (All rounded to 4 decimal places)
<ul>
<li>accuracy</li>
<li>recall</li>
<li>precision</li>
<li>fscore</li>
<li>false positive rate (fpr)</li>
<li>false negative rate (fnr)</li>
<li>Area Under the Curve of Receiver Operating Characteristics Curve (roc_auc)</li>
</ul>
</li>
<li>Create a Feature Importance DataFrame from the trained model:
<ul>
<li><strong>Do Not Use RFE for feature selection</strong></li>
<li>Use the top 10 features selected by the built in method (sorted from biggest to smallest)</li>
<li>Make sure you use the same feature and importance column names as ModelMetrics shows in feat_name_col [Feature] and imp_col [Importance]</li>
<li>round the importances to 4 decimal places (<strong>do this step after you have sorted by Importance</strong>)</li>
<li>Reset the index to 0-9 you can do this the same way you did in task1</li>
</ul>
</li>
</ul>
<strong>NOTE:</strong>&nbsp;Make sure you use the predicted probabilities for roc auc

Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details about submitting your work.

Useful Resources

<ul>
<li><a href="https://blog.dataiku.com/tree-based-models-how-they-work-in-plain-english">https://blog.dataiku.com/tree-based-models-how-they-work-in-plain-english</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score</a></li>
<li><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html</a></li>
</ul>
INPUTS

<ul>
<li>train_features&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>test_features&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>train_targets&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>test_targets&nbsp;– a dataset split by a function similar to the tts function you created in task2</li>
<li>gb_kwargs&nbsp;– a dictionary with keyword arguments that can be passed directly to the scikit-learn GradientBoostingClassifier class</li>
</ul>
OUTPUTS

<ul>
<li>A completed&nbsp;ModelMetrics&nbsp;object with a training and test metrics dictionary with each one of the metrics&nbsp;<strong>rounded to 4 decimal places</strong></li>
<li>An scikit-learn Gradient Boosted model object fit on the training set</li>
</ul>
Function Skeleton

def calculate_gradient_boosting_metrics(train_features:pd.DataFrame, test_features:pd.DataFrame, train_targets:pd.Series, test_targets:pd.Series, gb_kwargs) -&gt; tuple[ModelMetrics,GradientBoostingClassifier]:

model = GradientBoostingClassifier()

train_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0,

“fpr” : 0,

“fnr” : 0,

“roc_auc” : 0

}

test_metrics = {

“accuracy” : 0,

“recall” : 0,

“precision” : 0,

“fscore” : 0,

“fpr” : 0,

“fnr” : 0,

“roc_auc” : 0

}

&nbsp;

gb_importance = pd.DataFrame()

gb_metrics = ModelMetrics(“Gradient Boosting”,train_metrics,test_metrics,gb_importance)

&nbsp;

return gb_metrics,model

Example of Feature Importance DataFrame

<table>
<tbody>
<tr>
<td></td>
<td><strong>Feature</strong></td>
<td><strong>Importance</strong></td>
</tr>
<tr>
<td>0</td>
<td>android.permission.READ_PHONE_STATE</td>
<td>0.6046</td>
</tr>
<tr>
<td>1</td>
<td>com.google.android.c2dm.permission.RECEIVE</td>
<td>0.1994</td>
</tr>
<tr>
<td>2</td>
<td>android.permission.RECEIVE_BOOT_COMPLETED</td>
<td>0.0354</td>
</tr>
<tr>
<td>3</td>
<td>android.permission.INTERNET</td>
<td>0.0279</td>
</tr>
<tr>
<td>4</td>
<td>android.permission.SEND_SMS</td>
<td>0.0167</td>
</tr>
<tr>
<td>5</td>
<td>com.android.launcher.permission.INSTALL_SHORTCUT</td>
<td>0.0165</td>
</tr>
<tr>
<td>6</td>
<td>android.permission.READ_EXTERNAL_STORAGE</td>
<td>0.0115</td>
</tr>
<tr>
<td>7</td>
<td>android.permission.RECEIVE_USER_PRESENT</td>
<td>0.0109</td>
</tr>
<tr>
<td>8</td>
<td>android.permission.ACCESS_FINE_LOCATION</td>
<td>0.0095</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>android.permission.KILL_BACKGROUND_PROCESSES</td>
<td>0.0092</td>
</tr>
<tr>
<td>&nbsp;

&nbsp;
</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

Task 5: Model Training and Evaluation:

Now that you have written functions for different steps of the model-building process, you will put it all together. You will write code that trains a model with hyperparameters you determine (you should do any tuning locally or in a notebook, i.e., don’t tune your model in gradescope since the autograder will likely timeout).

<ul>
<li>Refer to the&nbsp;<a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/submissions.html">Submissions</a>&nbsp;page for details about submitting your work.</li>
</ul>
<strong>Important:</strong>&nbsp;Conduct hyperparameter tuning locally or in a separate notebook. Avoid tuning within Gradescope to prevent autograder timeouts.

<strong>Develop your own local tests to ensure your code functions correctly before submitting to Gradescope. Do not share these tests with other students.</strong>

train_model_return_scores&nbsp;(ClaMP Dataset)

Instructions (10 points):

This function focuses on training a model using the ClaMP dataset and evaluating its performance on a test set.

<ol>
<li><strong>Input:</strong>
<ul>
<li>train_df: A Pandas DataFrame containing the ClaMP training data. This includes the “class” column, which serves as your target variable (0 for benign, 1 for malicious).</li>
<li>test_df: A Pandas DataFrame containing the ClaMP test data.&nbsp;<strong>The “class” column is intentionally omitted from this set.</strong></li>
</ul>
</li>
<li><strong>Model Training:</strong>
<ul>
<li>Train a machine learning model using the&nbsp;train_df&nbsp;dataset.</li>
<li>You may use any techniques covered in this project.</li>
<li>Set a random seed for reproducibility.</li>
<li>Perform hyperparameter tuning to optimize your model’s performance
<ul>
<li>Tip: putting comments on the ranges you select for hyperparameters will help the graders understand how you chose it</li>
</ul>
</li>
</ul>
</li>
<li><strong>Prediction:</strong>
<ul>
<li>Use your trained model to predict the probability of malware for each row in the&nbsp;test_df.</li>
<li>Output these probabilities as values between 0 and 1. A value closer to 0 indicates a lower likelihood of malware, while a value closer to 1 indicates a higher likelihood.</li>
</ul>
</li>
<li><strong>Output:</strong>
<ul>
<li>Return a Pandas DataFrame with two columns:
<ul>
<li>index: The index from the input&nbsp;test_df.</li>
<li>malware_score: The predicted malware probabilities.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Evaluation:</strong>
<ul>
<li>The autograder will evaluate your predictions using the ROC AUC score.</li>
<li><strong>You must achieve a ROC AUC score of 0.9 or higher on the test set to receive full credit.</strong></li>
</ul>
</li>
</ol>
Sample Submission (ClaMP):

<table>
<tbody>
<tr>
<td><strong>index</strong></td>
<td><strong>malware_score</strong></td>
</tr>
<tr>
<td>0</td>
<td>0.65</td>
</tr>
<tr>
<td>1</td>
<td>0.1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
Function Skeleton (ClaMP):

import pandas as pd

&nbsp;

def train_model_return_scores(train_df, test_df) -&gt; pd.DataFrame:

“””

Trains a model on the ClaMP training data and returns predicted probabilities

for the test data.

&nbsp;

Args:

train_df (pd.DataFrame): ClaMP training data with ‘class’ column.

test_df (pd.DataFrame): ClaMP test data without ‘class’ column.

&nbsp;

Returns:

pd.DataFrame: DataFrame with ‘index’ and ‘malware_score’ columns.

“””

<em># TODO: Implement the model training and prediction logic as described above.</em>

test_scores = pd.DataFrame()&nbsp; <em># Replace with your implementation</em>

return test_scores

train_model_unsw_return_scores&nbsp;(UNSW-NB15 Dataset)

Instructions (10 points):

This function is similar to the previous one but uses the UNSW-NB15 dataset.

<ol>
<li><strong>Input:</strong>
<ul>
<li>train_df: A Pandas DataFrame containing the UNSW-NB15 training data (including the “class” column).</li>
<li>test_df: A Pandas DataFrame containing the UNSW-NB15 test data (without the “class” column).</li>
</ul>
</li>
<li><strong>Model Training:</strong>
<ul>
<li>Train a machine learning model using the&nbsp;train_df.</li>
<li>You can use any techniques from this project.</li>
<li>Set a random seed for reproducibility.</li>
</ul>
</li>
<li><strong>Prediction:</strong>
<ul>
<li>Predict the probability of class=1 for each row in&nbsp;test_df.</li>
<li>Output probabilities between 0 and 1, where values closer to 1 indicate a higher likelihood of being class=1.</li>
</ul>
</li>
<li><strong>Output:</strong>
<ul>
<li>Return a Pandas DataFrame with two columns:
<ul>
<li>index: The index from the input&nbsp;test_df.</li>
<li>prob_class_1: The predicted probabilities of class=1.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Evaluation:</strong>
<ul>
<li>The autograder will evaluate your predictions using the ROC AUC score.</li>
<li>Full Credit (10 points) will be given for 0.76 and above, 5 points for .75 and above and 2.5 points for .55 and above</li>
<li>Parameter tuning will likely be necessary to achieve higher scores.</li>
</ul>
</li>
</ol>
Sample Submission (UNSW-NB15):

<table>
<tbody>
<tr>
<td><strong>index</strong></td>
<td><strong>prob_class_1</strong></td>
</tr>
<tr>
<td>0</td>
<td>0.65</td>
</tr>
<tr>
<td>1</td>
<td>0.1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
Function Skeleton (UNSW-NB15):

import pandas as pd

&nbsp;

def train_model_unsw_return_scores(train_df, test_df) -&gt; pd.DataFrame:

“””

Trains a model on the UNSW-NB15 training data and returns predicted

probabilities for the test data.

&nbsp;

Args:

train_df (pd.DataFrame): UNSW-NB15 training data with ‘class’ column.

test_df (pd.DataFrame): UNSW-NB15 test data without ‘class’ column.

&nbsp;

Returns:

pd.DataFrame: DataFrame with ‘index’ and ‘prob_class_1’ columns.

“””

<em># TODO: Implement the model training and prediction logic as described above.</em>

test_scores = pd.DataFrame()&nbsp; <em># Replace with your implementation</em>

return test_scores

Deliverables

<ol>
<li><strong>Local Testing:</strong>&nbsp;We strongly encourage you to thoroughly test your code locally using the provided datasets. Create your own test sets by splitting the training data.</li>
<li><strong>Gradescope Submission:</strong>&nbsp;Once you are confident in your solution, submit your&nbsp;task5.py&nbsp;file (containing both functions) to Gradescope.</li>
</ol>
Dataset Information

ClaMP Dataset

<ul>
<li>The ClaMP (Classification of Malware with PE Headers) dataset is used for malware classification.</li>
<li>It is based on the header fields of Portable Executable (PE) files.</li>
<li>Learn more about PE files:
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">Microsoft – PE Format</a></li>
<li><a href="https://en.wikipedia.org/wiki/Portable_Executable">Wikipedia – Portable Executable</a></li>
</ul>
</li>
<li>ClaMP Dataset GitHub Repository:&nbsp;<a href="https://github.com/urwithajit9/ClaMP">https://github.com/urwithajit9/ClaMP</a></li>
<li>This project uses the&nbsp;ClaMP_Raw-5184.csv&nbsp;file (55 features).</li>
</ul>
UNSW-NB15 Dataset

<ul>
<li>The UNSW-NB15 dataset was created using the IXIA PerfectStorm tool to simulate real-world network traffic and attack scenarios.</li>
<li>Dataset Website:&nbsp;<a href="https://research.unsw.edu.au/projects/unsw-nb15-dataset">https://research.unsw.edu.au/projects/unsw-nb15-dataset</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/UNSW-NB15-Description.pdf">Dataset Description</a></li>
<li><a href="https://github.gatech.edu/pages/cs6035-tools/cs6035-tools.github.io/Projects/Machine_Learning/UNSW-NB15-Feature-Descriptions.pdf">Feature Descriptions</a></li>
<li>Note: This project does not use all features or classes from the original UNSW-NB15 dataset.</li>
</ul>
&nbsp;
